import 'dart:async';

import 'package:conduit_core/conduit_core.dart';
import 'package:conduit_mysql/conduit_mysql.dart';
import 'package:test/test.dart';

import '../not_tests/mysql_test_config.dart';

/*
The purpose of these tests is to ensure that the SQL generated by diff'ing a schema creates the desired database.
These tests run queries against a database after it has been manipulated to ensure that the intended effect is met.
This is different than schema_generator_sql_mapping_test and generate_code_test. Those tests ensure a one-to-one mapping
between a builder command (e.g. createTable) and the generate SQL/Dart command.
 */

void main() {
  late MySqlPersistentStore store;

  setUp(() async {
    store = MySqlTestConfig().persistentStore();
    await store.execute('DROP TABLE IF EXISTS foo,bar,t,u,v');
  });

  tearDown(() async {
    await store.close();
  });

  group("Tables", () {
    test("Add table to schema", () async {
      final cmds = await applyDifference(
        store,
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn(
              "id",
              ManagedPropertyType.integer,
              isPrimaryKey: true,
            )
          ])
        ]),
      );

      expect(cmds.length, 1);
      final defs = await TableDefinition.get(store, ["foo"]);

      expect(defs["foo"]!.columns.length, 1);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);
    });

    test("Add multiple, unrelated tables", () async {
      final cmds = await applyDifference(
        store,
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn(
              "id",
              ManagedPropertyType.integer,
              isPrimaryKey: true,
            )
          ]),
          SchemaTable("bar", [
            SchemaColumn(
              "id",
              ManagedPropertyType.integer,
              isPrimaryKey: true,
            )
          ])
        ]),
      );

      expect(cmds.length, 2);

      final defs = await TableDefinition.get(store, ["foo", "bar"]);

      expect(defs["foo"]!.columns.length, 1);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);

      expect(defs["bar"]!.columns.length, 1);
      defs["bar"]!.expectColumn("id", "int", primaryKey: true);
    });

    test("Delete multiple, unrelated tables", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("bar", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ])
        ]),
        Schema.empty()
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["foo", "bar"]);

      expect(defs["foo"]!.columns.length, 1);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);

      expect(defs["bar"]!.columns.length, 1);
      defs["bar"]!.expectColumn("id", "int", primaryKey: true);

      await applyDifference(store, schemas[1], schemas[2]);

      defs = await TableDefinition.get(store, ["foo", "bar"]);
      expect(defs.length, 0);
    });

    test("Add unique constraint to table", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("a", ManagedPropertyType.integer)
          ]),
        ]),
        Schema([
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("a", ManagedPropertyType.integer),
              SchemaColumn("b", ManagedPropertyType.integer, isNullable: true),
            ],
            uniqueColumnSetNames: ["a", "b"],
          ),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["u"]);
      expect(defs["u"]!.uniqueSet, isEmpty);

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["u"]);
      expect(defs["u"]!.uniqueSet, ["a", "b"]);
    });

    test("Remove unique constraint from table", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("a", ManagedPropertyType.integer),
              SchemaColumn("b", ManagedPropertyType.integer)
            ],
            uniqueColumnSetNames: ["a", "b"],
          ),
        ]),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("a", ManagedPropertyType.integer),
            SchemaColumn("b", ManagedPropertyType.integer),
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["u"]);
      expect(defs["u"]!.uniqueSet, ["a", "b"]);

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["u"]);
      expect(defs["u"]!.uniqueSet, isEmpty);
    });

    test("Modify unique constraint on table", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("a", ManagedPropertyType.integer),
              SchemaColumn("b", ManagedPropertyType.integer)
            ],
            uniqueColumnSetNames: ["a", "b"],
          ),
        ]),
        Schema([
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("a", ManagedPropertyType.integer),
              SchemaColumn("b", ManagedPropertyType.integer),
              SchemaColumn("c", ManagedPropertyType.integer, isNullable: true)
            ],
            uniqueColumnSetNames: ["b", "c"],
          ),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["u"]);
      expect(defs["u"]!.uniqueSet, ["a", "b"]);

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["u"]);
      expect(defs["u"]!.uniqueSet, ["b", "c"]);
    });

    test("Create new table with foreign key in its unique column set",
        () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("x", ManagedPropertyType.integer),
              SchemaColumn.relationship(
                "ref",
                ManagedPropertyType.integer,
                relatedTableName: "t",
                relatedColumnName: "id",
              )
            ],
            uniqueColumnSetNames: ["x", "ref"],
          ),
        ])
      ];
      await applyDifference(store, schemas[0], schemas[1]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      expect(defs["u"]!.uniqueSet, isNotEmpty);
      expect(defs["u"]!.uniqueSet..sort(), ["ref_id", "x"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test(
        "Add new foreign key column while setting a new unique column set that contains it",
        () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.integer),
          ]),
        ]),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("x", ManagedPropertyType.integer),
              SchemaColumn.relationship(
                "ref",
                ManagedPropertyType.integer,
                relatedTableName: "t",
                relatedColumnName: "id",
              )
            ],
            uniqueColumnSetNames: ["x", "ref"],
          ),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      expect(defs["u"]!.uniqueSet, isNotNull);
      expect(defs["u"]!.uniqueSet..sort(), ["ref_id", "x"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test(
        "Add new foreign key column while changing a unique column set to contain that foreign key",
        () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("x", ManagedPropertyType.integer),
              SchemaColumn("y", ManagedPropertyType.integer),
            ],
            uniqueColumnSetNames: ["x", "y"],
          ),
        ]),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable(
            "u",
            [
              SchemaColumn(
                "id",
                ManagedPropertyType.integer,
                isPrimaryKey: true,
              ),
              SchemaColumn("x", ManagedPropertyType.integer),
              SchemaColumn("y", ManagedPropertyType.integer),
              SchemaColumn.relationship(
                "ref",
                ManagedPropertyType.integer,
                relatedTableName: "t",
                relatedColumnName: "id",
              )
            ],
            uniqueColumnSetNames: ["x", "y", "ref"],
          ),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      expect(defs["u"]!.uniqueSet, isNotNull);
      expect(defs["u"]!.uniqueSet..sort(), ["ref_id", "x", "y"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });
  });

  group("Columns (no relationship)", () {
    test("Add column", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.string)
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);
      defs["foo"]!.expectColumn("x", "text");
    });

    test("Add multiple columns", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.string),
            SchemaColumn(
              "y",
              ManagedPropertyType.datetime,
              isIndexed: true,
              isNullable: true,
              isUnique: true,
              defaultValue: "'1900-01-01 00:00:00'",
            )
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);
      defs["foo"]!.expectColumn("x", "text");
      defs["foo"]!.expectColumn(
        "y",
        "datetime",
        defaultValue: "1900-01-01 00:00:00",
        nullable: true,
        indexed: true,
        unique: true,
      );
    });

    test("Add column with autoincrementing", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn(
              "x",
              ManagedPropertyType.bigInteger,
              autoincrement: true,
            ),
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);
      defs["foo"]!.expectColumn("x", "bigint unsigned",
          indexed: true, unique: true, autoincrementing: true);
    });

    test("Delete column", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["foo"]);
      expect(defs["foo"]!.columns.length, 1);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);
    });

    test("Delete multiple columns", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger),
            SchemaColumn("y", ManagedPropertyType.document),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["foo"]);
      expect(defs["foo"]!.columns.length, 1);
      defs["foo"]!.expectColumn("id", "int", primaryKey: true);
    });

    // perform operations on multiple columns - esp. to get scenarios where unique and index are mixed

    test("Modify index", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger, isIndexed: true),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger),
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      var defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint", indexed: true);

      await applyDifference(store, schemas[2], schemas[3]);
      defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint");
    });

    test("Modify defaultValue", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn(
              "x",
              ManagedPropertyType.bigInteger,
            ),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn(
              "x",
              ManagedPropertyType.bigInteger,
              defaultValue: "1",
            ),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn(
              "x",
              ManagedPropertyType.bigInteger,
            ),
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      var defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint", defaultValue: "1");

      await applyDifference(store, schemas[2], schemas[3]);
      defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint");
    });

    test("Modify unique", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger, isUnique: true),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger),
          ]),
        ]),
      ];
      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      var defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint", indexed: true, unique: true);

      await applyDifference(store, schemas[2], schemas[3]);
      defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint");
    });

    test("Modify nullability", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn(
              "x",
              ManagedPropertyType.bigInteger,
            ),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn("x", ManagedPropertyType.bigInteger, isNullable: true),
          ]),
        ]),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn(
              "x",
              ManagedPropertyType.bigInteger,
            ),
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      var defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint", nullable: true);

      await applyDifference(store, schemas[2], schemas[3]);
      defs = await TableDefinition.get(store, ["foo"]);
      defs["foo"]!.expectColumn("x", "bigint");
    });
  });

  group("Relationships", () {
    test("Add tables, one with a foreign key to another", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("In reverse order, add tables, one with a foreign key to another",
        () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("Create tables with foreign key references to one another", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "u",
              relatedColumnName: "id",
            )
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
      defs["t"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "u",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("Create table with foreign key reference to itself", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["t"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("Create 3 tables with cyclical foreign keys", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "u",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "v",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("v", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      final defs = await TableDefinition.get(store, ["t", "u", "v"]);
      defs["t"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "u",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "v",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
      defs["v"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("Add a table with a foreign key to an existing table", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
        Schema([
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);

      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test(
        "Add a new table and a foreign key from an existing table to the new table",
        () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ]),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("Add a new foreign key column", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );
    });

    test("Add a new unique (has-one) foreign key column", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
              isUnique: true,
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        unique: true,
        deleteRule: "SET NULL",
      );
    });

    test("Remove foreign key column", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      expect(defs["u"]!.columns.length, 1);
      expect(defs["u"]!.columns.first.name, "id");
    });

    test("Remove foreign key column after rows have already been inserted",
        () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
        Schema([
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      await store.execute("INSERT INTO t (id) VALUES (1)");
      await store.execute("INSERT INTO u (id, ref_id) VALUES (1,1)");
      await applyDifference(store, schemas[1], schemas[2]);
      final defs = await TableDefinition.get(store, ["t", "u"]);
      expect(defs["u"]!.columns.length, 1);
      expect(defs["u"]!.columns.first.name, "id");
    });

    test("Modify delete rule", () async {
      final base = Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn.relationship(
            "ref",
            ManagedPropertyType.integer,
            relatedTableName: "t",
            relatedColumnName: "id",
          )
        ]),
        SchemaTable("t", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
        ]),
      ]);

      final schemas = [
        Schema.empty(),
        base,
        Schema.from(base)
          ..tableForName("u")!.columnForName("ref")!.deleteRule =
              DeleteRule.cascade,
        Schema.from(base)
          ..tableForName("u")!.columnForName("ref")!.deleteRule =
              DeleteRule.restrict,
        Schema.from(base)
          ..tableForName("u")!.columnForName("ref")!.deleteRule =
              DeleteRule.setDefault,
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "CASCADE",
      );

      await applyDifference(store, schemas[2], schemas[3]);
      defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "RESTRICT",
      );

      await applyDifference(store, schemas[3], schemas[4]);
      defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET DEFAULT",
      );
    });

    test(
      "Modify foreign key nullability",
      () async {
        final schemas = [
          Schema.empty(),
          Schema([
            SchemaTable("u", [
              SchemaColumn("id", ManagedPropertyType.integer,
                  isPrimaryKey: true),
              SchemaColumn.relationship(
                "ref",
                ManagedPropertyType.integer,
                relatedTableName: "t",
                relatedColumnName: "id",
              )
            ]),
            SchemaTable("t", [
              SchemaColumn("id", ManagedPropertyType.integer,
                  isPrimaryKey: true),
            ]),
          ]),
          Schema([
            SchemaTable("u", [
              SchemaColumn("id", ManagedPropertyType.integer,
                  isPrimaryKey: true),
              SchemaColumn.relationship(
                "ref",
                ManagedPropertyType.integer,
                relatedTableName: "t",
                relatedColumnName: "id",
                rule: DeleteRule.cascade,
                isNullable: false,
              )
            ]),
            SchemaTable("t", [
              SchemaColumn("id", ManagedPropertyType.integer,
                  isPrimaryKey: true),
            ]),
          ])
        ];

        await applyDifference(store, schemas[0], schemas[1]);
        var defs = await TableDefinition.get(store, ["t", "u"]);
        defs["u"]!.expectColumn(
          "ref_id",
          "int",
          nullable: true,
          relatedTableName: "t",
          relatedColumnName: "id",
          deleteRule: "SET NULL",
        );

        await applyDifference(store, schemas[1], schemas[2]);
        defs = await TableDefinition.get(store, ["t", "u"]);
        defs["u"]!.expectColumn(
          "ref_id",
          "int",
          relatedTableName: "t",
          relatedColumnName: "id",
          deleteRule: "CASCADE",
        );
      },
      skip: true,
    );

    test("Delete tables that have a relationship", () async {
      final schemas = [
        Schema.empty(),
        Schema([
          SchemaTable("v", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
          SchemaTable("u", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
            SchemaColumn.relationship(
              "ref",
              ManagedPropertyType.integer,
              relatedTableName: "t",
              relatedColumnName: "id",
            )
          ]),
          SchemaTable("t", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          ]),
        ]),
        Schema([
          SchemaTable("v", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ]),
        ])
      ];

      await applyDifference(store, schemas[0], schemas[1]);
      var defs = await TableDefinition.get(store, ["t", "u"]);
      defs["u"]!.expectColumn(
        "ref_id",
        "int",
        nullable: true,
        relatedTableName: "t",
        relatedColumnName: "id",
        deleteRule: "SET NULL",
      );

      await applyDifference(store, schemas[1], schemas[2]);
      defs = await TableDefinition.get(store, ["t", "u", "v"]);
      expect(defs.length, 1);
      expect(defs.containsKey("v"), true);
    });
  });
}

Future<List<String>> applyDifference(
  PersistentStore store,
  Schema baseSchema,
  Schema newSchema,
) async {
  final diff = baseSchema.differenceFrom(newSchema);
  final commands =
      SchemaBuilder.fromDifference(store, diff, isTemporary: false).commands;

  await Future.forEach(commands, (String c) async {
    await store.execute(c);
  });
  return commands;
}

class TableDefinition {
  TableDefinition(this.name);

  static Future<Map<String, TableDefinition>> get(
    MySqlPersistentStore store,
    List<String> tableNames,
  ) async {
    final tables = await Future.wait(
      tableNames.map((t) async {
        final def = TableDefinition(t);
        await def.resolve(store);
        return def;
      }),
    );

    final m = <String, TableDefinition>{};
    for (final t in tables) {
      if (t.isValid) {
        m[t.name] = t;
      }
    }

    return m;
  }

  void expectColumn(
    String name,
    String dataType, {
    String? defaultValue,
    bool unique = false,
    bool primaryKey = false,
    bool nullable = false,
    bool indexed = false,
    bool autoincrementing = false,
    String? relatedTableName,
    String? relatedColumnName,
    String? deleteRule,
  }) {
    final col = columns.firstWhere(
      (c) => c.name == name,
      orElse: () => fail("column $name doesn't exist"),
    );
    expect(col.dataType, dataType, reason: "$name data type");
    expect(col.defaultValue, defaultValue, reason: "$name default value");
    expect(col.isPrimaryKey, primaryKey, reason: "$name primary key");
    expect(col.isNullable, nullable, reason: "$name nullable");
    expect(
      col.isAutoincrementing,
      autoincrementing,
      reason: "$name autoincrement",
    );

    // if column is expected to be a pk, it is always indexed and unique.
    // if column is relationship, it is always indexed
    if (primaryKey) {
    } else if (relatedTableName != null || relatedColumnName != null) {
      expect(col.isIndexed, true, reason: "$name indexed");
      expect(col.isUnique, unique, reason: "$name unique");
    } else {
      expect(col.isIndexed, indexed, reason: "$name indexed");
      expect(col.isUnique, unique, reason: "$name unique");
    }

    expect(
      col.relatedColumnName,
      relatedColumnName,
      reason: "$name related column name",
    );
    expect(
      col.relatedTableName,
      relatedTableName,
      reason: "$name related table name",
    );
    expect(col.deleteRule, deleteRule, reason: "$name delete rule");
  }

  final String name;
  late List<ColumnDefinition> columns;
  late bool isValid;

  List<String> uniqueSet = [];

  Future<void> resolve(MySqlPersistentStore store) async {
    List<Map<String, dynamic>> exists;

    try {
      exists = await store.execute(
        "DESCRIBE $name;",
      ) as List<Map<String, dynamic>>;
    } catch (e) {
      isValid = false;
      return;
    }

    isValid = exists.isNotEmpty;
    if (!isValid) {
      return;
    }

    final results = await store.execute(
      "DESCRIBE $name",
    ) as List<Map<String, dynamic>>;
    columns = results.map((row) {
      return ColumnDefinition(row);
    }).toList();

    final constraints = await store.execute(
            "SELECT c.column_name, t.constraint_type FROM information_schema.key_column_usage AS c "
            "LEFT JOIN information_schema.table_constraints AS t ON t.constraint_name = c.constraint_name WHERE t.table_name = '$name'")
        as List<Map<String, dynamic>>;
    for (final constraint in constraints) {
      final col =
          columns.firstWhere((c) => c.name == constraint['COLUMN_NAME']);

      if (constraint['constraint_type'] == "UNIQUE") {
        col.isUnique = true;
      } else if (constraint['constraint_type'] == "PRIMARY KEY") {
        col.isPrimaryKey = true;
      }
    }

    final indices = await store.execute(
      "SHOW INDEX FROM $name",
    ) as List<Map<String, dynamic>>;

    for (final idx in indices) {
      if (idx['Index_type'] != 'BTREE') {
        columns.firstWhere((c) => c.name == idx['Column_name']).isIndexed =
            true;
      }

      if (idx['Key_name'] == 'u_unique_idx') {
        uniqueSet.add(idx['Column_name']!);
      }
    }

    final foreignKeys = await store.execute(
            "SELECT * FROM information_schema.table_constraints tc "
            "INNER JOIN information_schema.referential_constraints rc ON (tc.constraint_name=rc.constraint_name) "
            "INNER JOIN information_schema.key_column_usage kcu ON (tc.constraint_name=kcu.constraint_name) "
            "WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_name ='$name';")
        as List<Map<String, dynamic>>;
    for (final foreignKey in foreignKeys) {
      final col =
          columns.firstWhere((c) => c.name == foreignKey['COLUMN_NAME']);

      col.relatedTableName = foreignKey['REFERENCED_TABLE_NAME'] as String;
      col.relatedColumnName = foreignKey['REFERENCED_COLUMN_NAME'] as String;
      col.deleteRule = foreignKey['DELETE_RULE'] as String;
    }
  }
}

class ColumnDefinition {
  ColumnDefinition(Map<String, dynamic> row) {
    name = row['Field'] as String;
    dataType = row['Type'] as String;
    isNullable = row['Null'] == "YES";
    defaultValue = row['Default'];
    isPrimaryKey = row['Key'] == ('PRI');
    isIndexed = (row['Key'] as String).isNotEmpty;
    isUnique = row['Key'] == 'PRI' || row['Key'] == 'UNI';

    final def = row['Extra'] as String?;
    if (def != null && def.contains("auto_increment")) {
      isAutoincrementing = true;
    }
  }

  String? relatedTableName;
  String? relatedColumnName;
  String? deleteRule;

  // default = 'value'::type
  String? defaultValue;

  // text, timestamp without time zone, jsonb, etc.
  String? name;
  String? dataType;
  bool isUnique = false;
  bool isPrimaryKey = false;
  bool? isNullable;
  bool isIndexed = false;
  bool isAutoincrementing = false;
}
